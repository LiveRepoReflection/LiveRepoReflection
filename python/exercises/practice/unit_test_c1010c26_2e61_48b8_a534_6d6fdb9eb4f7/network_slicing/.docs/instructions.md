## Project Name:

```
optimal-network-slicing
```

## Question Description:

A telecommunications company is rolling out 5G network services. To efficiently utilize their infrastructure and cater to diverse customer needs, they employ network slicing. You are tasked with developing an algorithm to optimally slice the network resources (bandwidth and compute) across different service types, maximizing overall revenue while adhering to strict Quality of Service (QoS) requirements.

**Input:**

*   `total_bandwidth`: An integer representing the total available bandwidth of the network (in MHz).
*   `total_compute`: An integer representing the total available compute resources of the network (in CPU cores).
*   `slices`: A list of dictionaries, where each dictionary represents a network slice type with the following keys:
    *   `slice_id`: A unique string identifier for the slice.
    *   `service_type`: A string representing the service type (e.g., "eMBB", "URLLC", "mMTC").
    *   `bandwidth_demand`: An integer representing the required bandwidth for a single instance of this slice type (in MHz).
    *   `compute_demand`: An integer representing the required compute resources for a single instance of this slice type (in CPU cores).
    *   `revenue_per_instance`: A float representing the revenue generated by a single instance of this slice type.
    *   `qos_requirements`: A dictionary representing QoS requirements for this slice type.  It must include at least one key such as 'max_latency_ms' to specify constraints.

**Output:**

A dictionary containing the following keys:

*   `allocation`: A dictionary where keys are slice IDs and values are the number of instances allocated to that slice.
*   `total_revenue`: A float representing the total revenue generated by the optimal allocation.
*   `unallocated_slices`: A list of slice IDs that could not be allocated any instances due to resource constraints or QoS violations.
*   `resource_utilization`: A dictionary where keys are 'bandwidth' and 'compute', and values are floats representing the percentage of bandwidth and compute resources utilized, respectively.

**Constraints and Considerations:**

*   **Resource Constraints:** The total bandwidth and compute resources allocated to all slices cannot exceed `total_bandwidth` and `total_compute`, respectively.
*   **QoS Requirements:** The allocation must satisfy all QoS requirements specified for each slice type. Consider that increasing the number of instances of one slice could negatively affect the QoS of other slices. For example, sharing bandwidth reduces QoS. You will need to determine how resource allocation impacts QoS, and ensure all slices meet their requirement.
*   **Integer Allocation:** The number of instances allocated to each slice must be a non-negative integer. Fractional instances are not allowed.
*   **Optimization Goal:** The primary goal is to maximize the `total_revenue`.
*   **Complexity:** Due to the combinatorial nature of the problem, a brute-force approach is likely infeasible for a large number of slice types or high resource demands.  Efficient algorithms and data structures are essential.
*   **Real-world Considerations:**  The problem should reflect real-world scenarios. You can assume a simplified model for how resource allocation affects QoS.
*   **Scalability:** The solution should be scalable to handle a large number of slices and high resource demands.  Think about how the chosen data structures and algorithms will perform as the input size increases.
*   **Multiple Optimal Solutions:** If multiple optimal solutions exist (i.e., different allocations that yield the same maximum revenue), your algorithm can return any one of them.
*   **Unallocatable Slices:** Handle cases where some slices cannot be allocated any instances due to resource constraints or QoS requirements.  The `unallocated_slices` list must contain the IDs of these slices.

**Example:**

```python
total_bandwidth = 100
total_compute = 50
slices = [
    {
        "slice_id": "eMBB_1",
        "service_type": "eMBB",
        "bandwidth_demand": 20,
        "compute_demand": 10,
        "revenue_per_instance": 10.0,
        "qos_requirements": {"max_latency_ms": 50}
    },
    {
        "slice_id": "URLLC_1",
        "service_type": "URLLC",
        "bandwidth_demand": 10,
        "compute_demand": 5,
        "revenue_per_instance": 20.0,
        "qos_requirements": {"max_latency_ms": 1}
    },
    {
        "slice_id": "mMTC_1",
        "service_type": "mMTC",
        "bandwidth_demand": 5,
        "compute_demand": 2,
        "revenue_per_instance": 5.0,
        "qos_requirements": {"max_latency_ms": 100}
    },
]

# Expected output (may vary depending on the optimal solution):
# {
#     'allocation': {'eMBB_1': 2, 'URLLC_1': 1, 'mMTC_1': 0},
#     'total_revenue': 40.0,
#     'unallocated_slices': ['mMTC_1'],
#     'resource_utilization': {'bandwidth': 50.0, 'compute': 50.0}
# }
```

**Scoring:**

The solution will be evaluated based on the following criteria:

*   **Correctness:** The algorithm must produce a valid allocation that satisfies all constraints and QoS requirements.
*   **Optimality:** The algorithm must maximize the total revenue generated by the allocation.
*   **Efficiency:** The algorithm must be efficient and scalable to handle large input sizes.
*   **Code Quality:** The code must be well-structured, readable, and documented.

This problem requires a deep understanding of optimization techniques, resource allocation strategies, and system design principles. Good luck!
