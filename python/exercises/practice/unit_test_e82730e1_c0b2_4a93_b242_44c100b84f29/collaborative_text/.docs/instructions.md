## Problem: Decentralized Collaborative Editing with Conflict Resolution

**Description:**

You are tasked with designing a system for decentralized, collaborative editing of a large document. Imagine a scenario where multiple users are simultaneously editing different sections of a shared document. The system must handle concurrent edits, potential conflicts, and maintain data consistency across all users' local copies.

**Specifically, you need to implement a simplified model of a conflict-free replicated data type (CRDT), focusing on a text document.**

The document is represented as a sequence of characters. Each user has a local copy of the document and can perform the following operations:

*   **Insert(position, char):** Inserts a character `char` at the given `position`.
*   **Delete(position):** Deletes the character at the given `position`.

Due to network latency and asynchronicity, users' operations might arrive out of order or concurrently. Your goal is to design a system that ensures eventual consistency, meaning that all replicas will converge to the same final state, regardless of the order in which operations are applied.

**Challenges:**

1.  **Operation Identification:** Design a mechanism to uniquely identify each operation generated by any user. This is crucial for ordering and conflict resolution.
2.  **Concurrent Inserts:** Address the challenge of concurrent insertions at the same position. If two users insert characters at the same logical position, the system needs a deterministic way to order these insertions.
3.  **Insert-Delete Conflicts:** Handle the scenario where one user inserts a character and another user concurrently deletes the character at the same position.
4.  **Delete-Insert Conflicts:** Handle the scenario where one user deletes a character and another user concurrently inserts a character at the same position.
5.  **Idempotency:** Ensure that applying the same operation multiple times has the same effect as applying it once. This is important because operations might be retransmitted due to network issues.
6.  **Efficiency:** Design the system to minimize the amount of data transferred between users. Avoid sending the entire document state for every operation.
7.  **Scalability:** Consider how the system would scale to handle a large number of users and a large document size. While you don't need to implement a fully distributed system, your design should be amenable to distribution.

**Requirements:**

*   Implement a `Document` class that represents the shared document.
*   Implement `Insert` and `Delete` methods within the `Document` class.
*   Design a suitable operation representation and identification scheme.
*   Implement a conflict resolution strategy that ensures eventual consistency.
*   The system must be robust to out-of-order delivery of operations.
*   The solution should be well-documented and easy to understand.

**Constraints:**

*   The document should be represented as a list of characters.
*   Positions are integer indices into the character list (0-based).
*   The system should handle insertions and deletions at any valid position within the document.
*   Focus on correctness and eventual consistency, but also consider efficiency and scalability.
*   Assume a reliable broadcast mechanism is available (i.e., all operations will eventually reach all users, but the order is not guaranteed). You don't need to implement the broadcast mechanism itself.
*   The solution must be implemented in Python.

**Judging Criteria:**

*   **Correctness:** The system must correctly handle concurrent edits and ensure eventual consistency.
*   **Conflict Resolution:** The conflict resolution strategy must be deterministic and well-defined.
*   **Efficiency:** The system should minimize the amount of data transferred and the computational complexity of applying operations.
*   **Scalability:** The design should be amenable to scaling to a large number of users and a large document size.
*   **Clarity and Documentation:** The code should be well-documented and easy to understand.
*   **Completeness:** All requirements should be addressed.
