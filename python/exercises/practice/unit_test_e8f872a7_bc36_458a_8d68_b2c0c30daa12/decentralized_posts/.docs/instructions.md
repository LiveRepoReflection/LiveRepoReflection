## Project Name

```
decentralized-social-network
```

## Question Description

You are tasked with designing and implementing a core component of a decentralized social network: the efficient storage and retrieval of user posts across a distributed network.  This network utilizes a Distributed Hash Table (DHT) for content addressing and storage.

**System Overview:**

1.  **User Posts:** Each user can create posts. A post consists of the user's ID, a timestamp, and the content of the post (a string).
2.  **Content Addressing:** Each post is assigned a unique content ID (CID) generated by hashing the post's content using SHA-256. The user ID, timestamp, and post content are all part of the content that gets hashed.
3.  **Distributed Hash Table (DHT):** The network consists of a large number of nodes, each identified by a unique node ID. The DHT is used to store and retrieve posts based on their CIDs. Specifically, a post with CID `X` is stored on the node with the node ID closest to `X` in the DHT's key space (using XOR distance as the proximity metric).
4.  **Post Retrieval:** Given a user ID, your system should efficiently retrieve all posts created by that user, sorted in descending order of timestamp.
5.  **Data Persistence:**  Each node in the DHT has limited storage capacity.  To ensure data persistence and availability, each post is replicated across `K` nodes closest to the CID.

**Your Task:**

Implement the following functions:

1.  `store_post(node_id: int, user_id: str, timestamp: int, content: str) -> str`: This function simulates a user creating a post and storing it in the DHT.
    *   It calculates the CID of the post.
    *   It determines the `K` closest nodes to the CID.
    *   It simulates storing the post on these `K` nodes.  For the purposes of this problem, you only need to return the CID of the post. You do NOT need to actually implement storage logic.
2.  `retrieve_posts(node_id: int, user_id: str) -> List[Tuple[int, str]]`: This function simulates retrieving all posts created by a user from the DHT.
    *   It efficiently identifies the potential storage locations of posts by the user.  This is non-trivial as posts are distributed based on their CIDs, not directly on the user ID.
    *   It simulates querying the relevant nodes for posts by the given user.
    *   It returns a list of `(timestamp, content)` tuples, sorted in descending order of timestamp.

**Constraints:**

*   **Efficiency:** The `retrieve_posts` function must be highly efficient. A naive approach of querying all nodes in the network will be too slow for large-scale social networks. Consider how to narrow down the search space effectively.
*   **Scalability:**  The system should be designed to handle a large number of users and posts.
*   **Data Distribution:**  Posts are distributed randomly based on their content.  You cannot assume any particular structure or locality in the DHT.
*   **K-Replication:** The replication factor `K` is a parameter that can be adjusted. Your solution should work correctly for different values of `K`.
*   **Network Size:** The network consists of a significant number of nodes. Assume there are 100000 nodes.
*   **Node IDs:** Node IDs are integers in the range `[0, 2**20 - 1]`.
*   **User IDs:** User IDs are strings.
*   **Timestamps:** Timestamps are integers representing Unix timestamps (seconds since epoch).
*   **Post Content:** Post content is a string.
*   **K Value:** The replication factor `K` will be between 1 and 20.

**Example:**

```python
# Example K = 5
store_post(12345, "user1", 1678886400, "Hello, world!")  # Returns a CID (e.g., "a1b2c3d4...")
store_post(67890, "user1", 1678886460, "Another post") # Returns a CID
posts = retrieve_posts(54321, "user1")  # Returns a list of (timestamp, content) tuples for user1, sorted by timestamp in descending order.
```

**Hints:**

*   Consider using a secondary index or a bloom filter to efficiently locate potential post storage locations.  Focus on minimizing the number of nodes that need to be queried for each user.
*   Think about how to leverage the K-replication strategy to improve retrieval efficiency.
*   XOR distance is a common metric in DHTs. Use the XOR operation (`^`) to calculate the distance between two node IDs.
*   You may need to make reasonable assumptions about the network topology and DHT implementation.
*   You'll need to determine how to hash the content to generate the CID.

This is a design-heavy problem.  Think about the trade-offs between different approaches and justify your design choices.  The focus is on algorithmic efficiency and scalability, not on implementing a fully functional distributed system.
