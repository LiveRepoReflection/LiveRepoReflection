## Project Name

```
distributed-transaction-manager
```

## Question Description

You are tasked with designing and implementing a simplified, yet robust, distributed transaction manager (DTM) in Go. This DTM will coordinate transactions across multiple independent services.

Imagine a scenario where a user wants to transfer funds from their account in Service A to another user's account in Service B. Both services have their own databases and are independent. A distributed transaction ensures that either both the debit from Service A *and* the credit to Service B happen, or neither of them do, maintaining data consistency.

**Core Requirements:**

1.  **Transaction Coordination:** Your DTM should be able to initiate, commit, and rollback distributed transactions.  It should assign a unique transaction ID (TXID) to each transaction.

2.  **Two-Phase Commit (2PC):** Implement the 2PC protocol.  This involves a *Prepare* phase where the DTM asks all participating services to tentatively perform their part of the transaction. If all services are ready, the DTM then initiates the *Commit* phase. If any service refuses to prepare, the DTM initiates the *Rollback* phase.

3.  **Participant Registration:** Services need a mechanism to register themselves as participants in a given transaction. Each participant will provide a Prepare, Commit, and Rollback endpoint (simulated via interfaces/functions, no actual network calls are needed).

4.  **Idempotency:** Your DTM must handle duplicate Prepare, Commit, and Rollback requests gracefully.  Each participant should execute its operation only once, even if the DTM sends multiple requests.

5.  **Crash Recovery (Simplified):**  The DTM itself should be able to recover from crashes.  Upon restart, it should resume any in-flight transactions based on a persistent log (simulated via in-memory data structures for simplicity, but explain clearly how you would persist this).  The DTM needs to determine the outcome (Commit or Rollback) and drive the transaction to completion, even if it crashed mid-way.  Assume services are always available upon DTM recovery.

6.  **Timeout Handling:** If a participant doesn't respond within a reasonable timeout during the Prepare phase, the DTM should assume the service failed to prepare and initiate a rollback.

**Constraints:**

*   **Concurrency:**  The DTM must be able to handle multiple concurrent transactions.
*   **Error Handling:**  Implement robust error handling.  Your DTM should gracefully handle failures and provide informative error messages.
*   **No External Dependencies:** You are **not** allowed to use external transaction management libraries (e.g., those provided by databases). The point is to implement the core logic. You *can* use standard Go libraries for concurrency, data structures, and logging.
*   **Simulated Services:**  Instead of implementing actual network services, you will simulate the behavior of the participating services using interfaces or function closures.

**Input:**

The DTM will receive requests to initiate transactions. Each request will contain:

*   A unique transaction ID (TXID).  This can be auto-generated by the DTM, or provided in the request.
*   A list of participants. Each participant will be represented by a struct containing:
    *   A unique participant ID.
    *   Prepare function: `func() error` - Returns `nil` on success, an error on failure.
    *   Commit function: `func() error` - Returns `nil` on success, an error on failure.
    *   Rollback function: `func() error` - Returns `nil` on success, an error on failure.

**Output:**

The DTM should return a result indicating whether the transaction committed successfully, rolled back successfully, or failed with an error.  The DTM should also log all important events (transaction start, prepare requests, commit/rollback decisions, errors, recovery events).

**Judging Criteria:**

*   **Correctness:** Does the DTM correctly implement the 2PC protocol and ensure atomicity?
*   **Robustness:** Does the DTM handle failures, timeouts, and concurrent transactions gracefully?
*   **Recoverability:** Can the DTM recover from crashes and resume in-flight transactions?
*   **Idempotency:** Does the DTM handle duplicate requests correctly?
*   **Code Quality:** Is the code well-structured, readable, and maintainable?  Are appropriate error handling and logging mechanisms used?
*   **Efficiency:** While performance is not the primary focus, avoid obvious inefficiencies. Consider the impact of your data structures and algorithms on performance.
*   **Design Rationale:** In comments, explain the design choices you made, especially regarding data structures, concurrency primitives, and recovery mechanisms. Justify your choices with trade-offs (e.g., favoring simplicity over extreme performance). Describe how you would persist transaction log in real world.
