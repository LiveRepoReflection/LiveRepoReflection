package optimalgraph

import (
	"math"
	"sort"
)

// OptimalGraph generates an optimal communication graph for the given microservices.
// It returns an adjacency matrix representing the graph.
//
// Parameters:
// - n: The number of microservices
// - capacities: An array of n integers representing the processing capacity of each service
// - generations: An array of n integers representing the number of requests generated by each service
// - dependencies: A list of n lists representing potential dependencies between services
//
// Returns:
// - An adjacency matrix representing the optimal communication graph
func OptimalGraph(n int, capacities, generations []int, dependencies [][]int) [][]bool {
	// Initialize the adjacency matrix with false values
	adjMatrix := make([][]bool, n)
	for i := range adjMatrix {
		adjMatrix[i] = make([]bool, n)
	}

	// Check if there's any service with generation exceeding capacity
	for i := 0; i < n; i++ {
		if generations[i] > capacities[i] {
			return adjMatrix // Return empty graph if no valid solution
		}
	}

	// First, determine a topological ordering that could minimize latency
	// We'll use a heuristic approach based on dependencies and capacities
	order := topologicalOrdering(n, capacities, generations, dependencies)
	if order == nil {
		return adjMatrix // No valid ordering found
	}

	// Create a mapping from node to its position in the ordering
	orderPos := make([]int, n)
	for i, node := range order {
		orderPos[node] = i
	}

	// Track remaining capacity for each service
	remainingCapacity := make([]int, n)
	copy(remainingCapacity, capacities)

	// Track accumulated requests for each service that need to be forwarded
	pendingRequests := make([]int, n)
	copy(pendingRequests, generations)

	// Assign dependencies starting from highest to lowest in our ordering
	for i := n - 1; i >= 0; i-- {
		service := order[i]
		
		// If this service has no dependencies, continue
		if len(dependencies[service]) == 0 {
			continue
		}

		// Sort potential dependencies by their order position (to minimize latency)
		potentialDeps := make([]int, len(dependencies[service]))
		copy(potentialDeps, dependencies[service])
		sort.Slice(potentialDeps, func(i, j int) bool {
			return orderPos[potentialDeps[i]] > orderPos[potentialDeps[j]]
		})

		// Try to allocate requests to dependencies respecting capacity constraints
		for _, dep := range potentialDeps {
			// Skip if it would create a cycle or capacity is exceeded
			if orderPos[dep] <= orderPos[service] || pendingRequests[service] <= 0 {
				continue
			}

			// Calculate how many requests we can allocate to this dependency
			requestsToAllocate := min(pendingRequests[service], remainingCapacity[dep])
			if requestsToAllocate > 0 {
				adjMatrix[service][dep] = true
				remainingCapacity[dep] -= requestsToAllocate
				pendingRequests[service] -= requestsToAllocate
				pendingRequests[dep] += requestsToAllocate
			}
		}
	}

	// If we couldn't allocate all requests, it means there's no valid solution
	for i := 0; i < n; i++ {
		if pendingRequests[i] > generations[i] {
			// Reset the matrix to all false
			for i := range adjMatrix {
				for j := range adjMatrix[i] {
					adjMatrix[i][j] = false
				}
			}
			return adjMatrix
		}
	}

	// Now optimize for latency by trying to minimize the number of hops
	optimizeLatency(adjMatrix, n, dependencies, orderPos)

	return adjMatrix
}

// topologicalOrdering determines a good topological ordering for the services
func topologicalOrdering(n int, capacities, generations []int, dependencies [][]int) []int {
	// Create a directed graph based on dependencies
	graph := make([][]int, n)
	for i := 0; i < n; i++ {
		graph[i] = make([]int, 0)
		for _, dep := range dependencies[i] {
			graph[i] = append(graph[i], dep)
		}
	}

	// Check if the graph is acyclic
	visited := make([]bool, n)
	recStack := make([]bool, n)
	for i := 0; i < n; i++ {
		if !visited[i] {
			if hasCycle(graph, i, visited, recStack) {
				return nil // Cycle detected, no valid ordering
			}
		}
	}

	// Use a custom ordering that prioritizes services with higher capacity to generation ratio
	// This is a heuristic to potentially minimize the maximum latency
	type ServiceNode struct {
		id    int
		score float64 // Higher score means higher priority in ordering
	}

	nodes := make([]ServiceNode, n)
	for i := 0; i < n; i++ {
		// Score is based on capacity to generation ratio and number of dependencies
		capacityFactor := float64(capacities[i]) / math.Max(1.0, float64(generations[i]))
		depFactor := 1.0 / math.Max(1.0, float64(len(dependencies[i])))
		nodes[i] = ServiceNode{
			id:    i,
			score: capacityFactor * depFactor,
		}
	}

	// Sort by score in descending order
	sort.Slice(nodes, func(i, j int) bool {
		return nodes[i].score > nodes[j].score
	})

	// Extract the ordering
	order := make([]int, n)
	for i, node := range nodes {
		order[i] = node.id
	}

	// Ensure the ordering respects dependencies
	// We need to verify that for all edges u->v, u appears before v in our ordering
	for i := 0; i < n; i++ {
		for _, dep := range dependencies[i] {
			posI := -1
			posDep := -1
			for j, id := range order {
				if id == i {
					posI = j
				}
				if id == dep {
					posDep = j
				}
			}
			// If dependency comes before the service, we need to swap
			if posDep < posI {
				// Instead of swapping, let's use a more formal topological sort
				// Since our heuristic ordering might not respect all dependencies
				return topologicalSort(graph, n)
			}
		}
	}

	return order
}

// topologicalSort performs a standard topological sort
func topologicalSort(graph [][]int, n int) []int {
	visited := make([]bool, n)
	stack := make([]int, 0)

	var dfs func(int)
	dfs = func(node int) {
		visited[node] = true
		for _, neighbor := range graph[node] {
			if !visited[neighbor] {
				dfs(neighbor)
			}
		}
		stack = append(stack, node)
	}

	for i := 0; i < n; i++ {
		if !visited[i] {
			dfs(i)
		}
	}

	// Reverse the stack to get the topological ordering
	order := make([]int, n)
	for i := 0; i < n; i++ {
		order[i] = stack[n-1-i]
	}

	return order
}

// hasCycle checks if the directed graph has a cycle using DFS
func hasCycle(graph [][]int, node int, visited, recStack []bool) bool {
	visited[node] = true
	recStack[node] = true

	for _, neighbor := range graph[node] {
		if !visited[neighbor] {
			if hasCycle(graph, neighbor, visited, recStack) {
				return true
			}
		} else if recStack[neighbor] {
			return true
		}
	}

	recStack[node] = false
	return false
}

// optimizeLatency tries to minimize the latency by removing redundant edges
// while maintaining the capacity constraints
func optimizeLatency(adjMatrix [][]bool, n int, dependencies [][]int, orderPos []int) {
	// For each node, check if we can remove edges while preserving connectivity
	for i := 0; i < n; i++ {
		outEdges := make([]int, 0)
		for j := 0; j < n; j++ {
			if adjMatrix[i][j] {
				outEdges = append(outEdges, j)
			}
		}

		// Sort outgoing edges by position in topological order (descending)
		sort.Slice(outEdges, func(a, b int) bool {
			return orderPos[outEdges[a]] > orderPos[outEdges[b]]
		})

		// For each edge, check if we can remove it
		for _, j := range outEdges {
			// Temporarily remove the edge
			adjMatrix[i][j] = false

			// Check if there's still a path from i to j through other edges
			if hasPath(adjMatrix, i, j, n) {
				// We can keep this edge removed
				continue
			}

			// Otherwise, restore the edge
			adjMatrix[i][j] = true
		}
	}
}

// hasPath checks if there's a path from source to target in the graph
func hasPath(adjMatrix [][]bool, source, target, n int) bool {
	visited := make([]bool, n)
	var dfs func(int) bool
	dfs = func(current int) bool {
		if current == target {
			return true
		}
		visited[current] = true
		for next := 0; next < n; next++ {
			if adjMatrix[current][next] && !visited[next] {
				if dfs(next) {
					return true
				}
			}
		}
		return false
	}
	return dfs(source)
}

// min returns the minimum of two integers
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}