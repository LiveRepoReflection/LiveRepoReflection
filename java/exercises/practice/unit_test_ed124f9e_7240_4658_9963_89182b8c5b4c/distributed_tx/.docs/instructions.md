## The Distributed Transaction Coordinator

**Problem Description:**

You are tasked with building a simplified Distributed Transaction Coordinator (DTC) for a microservices architecture. This system is responsible for ensuring the atomicity of transactions spanning multiple services. Due to network instability and service outages, achieving strong consistency is challenging. Therefore, you will implement a two-phase commit (2PC) protocol with specific fault-tolerance mechanisms.

Imagine a scenario where a user wants to transfer funds from their account in `Service A` to another user's account in `Service B`. Both services have their own databases. To ensure the transfer is atomic (either both services commit the change or neither does), the DTC will orchestrate a 2PC protocol.

**Services:**

*   **Service A & B:** These are independent services, each managing its own data and exposing an API for the DTC to interact with. They can either `prepare` to commit a transaction, `commit` the transaction, or `rollback` the transaction.
*   **DTC (Your Task):** This service coordinates the transaction across all participating services. It is responsible for initiating the 2PC protocol, handling potential failures, and ensuring the final outcome is consistent across all services.

**Two-Phase Commit (2PC) Protocol:**

1.  **Phase 1: Prepare Phase:** The DTC sends a `prepare` request to all participating services (Service A and B).
    *   Each service attempts to tentatively perform the transaction. If successful, it locks the necessary resources and responds with `PREPARED`. If it fails (e.g., insufficient funds, database error), it responds with `ABORT`.
2.  **Phase 2: Commit/Rollback Phase:**
    *   If the DTC receives `PREPARED` from all services, it sends a `commit` request to all services. Each service then permanently applies the transaction.
    *   If the DTC receives `ABORT` from any service, or a service doesn't respond within a timeout (see constraints below), it sends a `rollback` request to all services. Each service then reverts any tentative changes.

**Constraints and Requirements:**

*   **Timeouts:** Network communication is unreliable. The DTC must implement timeouts for all requests to services. If a service doesn't respond within a reasonable time (e.g., 5 seconds), the DTC should consider the request failed and trigger a rollback.
*   **Idempotency:** Services may receive duplicate `commit` or `rollback` requests due to network issues. Services must implement idempotency to handle these duplicate requests gracefully, ensuring that applying the same command multiple times has the same effect as applying it once.
*   **Crash Recovery:** The DTC itself can crash. You need to implement a simple logging mechanism (in-memory is sufficient for this problem) so that upon restart, the DTC can determine the status of ongoing transactions and resume the 2PC protocol to ensure consistency. The log should at least contain the transaction ID, participating service IDs, and the current state of the transaction (e.g., `PREPARING`, `COMMIT_SENT`, `ROLLBACK_SENT`, `COMMITTED`, `ROLLEDBACK`).
*   **Partial Failures:** Some services might succeed in the prepare phase, while others fail. The DTC needs to handle these scenarios gracefully and ensure all services eventually reach a consistent state (either all committed or all rolled back).
*   **Concurrency:** Multiple transactions can be initiated concurrently. The DTC must handle concurrent transactions correctly, preventing race conditions and ensuring data consistency.
*   **Service Unavailability:** A service might be temporarily unavailable during the prepare phase. The DTC should retry the `prepare` request a limited number of times (e.g., 3 retries) before giving up and initiating a rollback.
*   **Transaction IDs:** Generate unique transaction IDs for each transaction.
*   **Optimization (Important):**  Assume a large number of services could participate in a single transaction (potentially hundreds). The DTC should be designed to minimize the number of round trips required to complete the 2PC protocol, particularly during the commit/rollback phase. Consider using techniques like asynchronous communication or parallel processing to improve performance.
*   **Error Handling:** The DTC should handle exceptions gracefully, log errors, and provide informative error messages for debugging.

**Input:**

The input to your DTC will be a series of transaction requests. Each request will specify:

*   A unique transaction ID (generated by the system).
*   A list of participating service IDs (e.g., `[ServiceA, ServiceB]`).
*   The operation to be performed (e.g., `transferFunds(user1, user2, amount)`).

**Output:**

The DTC should output the final status of each transaction:

*   `COMMITTED`: If the transaction was successfully committed by all services.
*   `ROLLEDBACK`: If the transaction was rolled back.

**Judging Criteria:**

Your solution will be judged based on the following criteria:

*   **Correctness:** Does your DTC correctly implement the 2PC protocol and ensure atomicity across services in all scenarios (including failures)?
*   **Fault Tolerance:** Does your DTC handle timeouts, service unavailability, and DTC crashes gracefully?
*   **Concurrency:** Does your DTC correctly handle concurrent transactions?
*   **Performance:** Is your DTC optimized to handle a large number of participating services and minimize round trips?
*   **Code Quality:** Is your code well-structured, readable, and maintainable?
*   **Idempotency:** Do the services handle duplicate commit/rollback requests correctly?

This problem requires careful consideration of distributed systems concepts, concurrency, and fault tolerance. Good luck!
